use std::collections::HashMap;
use std::path::PathBuf;
use std::sync::Arc;

use anyhow::{anyhow, Result};
use chrono::{DateTime, Utc};
use layercake_code_analysis::analyzer::analyze_path;
use layercake_code_analysis::report::markdown::{strip_csv_blocks, MarkdownReporter};
use sea_orm::DatabaseConnection;
use serde::{Deserialize, Serialize};
use tokio::sync::Mutex;
use uuid::Uuid;

use crate::code_analysis_graph::analysis_to_graph;
use crate::services::data_set_service::DataSetService;

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct CodeAnalysisProfile {
    pub id: String,
    pub project_id: i32,
    pub file_path: String,
    pub dataset_id: Option<i32>,
    pub last_run: Option<DateTime<Utc>>,
    pub report: Option<String>,
}

#[derive(Clone)]
pub struct CodeAnalysisService {
    db: DatabaseConnection,
    profiles: Arc<Mutex<HashMap<String, CodeAnalysisProfile>>>,
}

impl CodeAnalysisService {
    pub fn new(db: DatabaseConnection) -> Self {
        Self {
            db,
            profiles: Arc::new(Mutex::new(HashMap::new())),
        }
    }

    pub async fn list(&self, project_id: i32) -> Result<Vec<CodeAnalysisProfile>> {
        let profiles = self.profiles.lock().await;
        Ok(profiles
            .values()
            .filter(|p| p.project_id == project_id)
            .cloned()
            .collect())
    }

    pub async fn create(
        &self,
        project_id: i32,
        file_path: String,
        dataset_id: Option<i32>,
    ) -> Result<CodeAnalysisProfile> {
        let profile = CodeAnalysisProfile {
            id: Uuid::new_v4().to_string(),
            project_id,
            file_path,
            dataset_id,
            last_run: None,
            report: None,
        };

        let mut profiles = self.profiles.lock().await;
        profiles.insert(profile.id.clone(), profile.clone());
        Ok(profile)
    }

    pub async fn update(
        &self,
        id: &str,
        file_path: Option<String>,
        dataset_id: Option<Option<i32>>,
    ) -> Result<CodeAnalysisProfile> {
        let mut profiles = self.profiles.lock().await;
        let profile = profiles
            .get_mut(id)
            .ok_or_else(|| anyhow!("Profile not found"))?;

        if let Some(path) = file_path {
            profile.file_path = path;
        }
        if let Some(ds) = dataset_id {
            profile.dataset_id = ds;
        }

        Ok(profile.clone())
    }

    pub async fn delete(&self, id: &str) -> Result<bool> {
        let mut profiles = self.profiles.lock().await;
        Ok(profiles.remove(id).is_some())
    }

    pub async fn run(&self, id: &str) -> Result<CodeAnalysisProfile> {
        let profile = {
            let profiles = self.profiles.lock().await;
            profiles
                .get(id)
                .cloned()
                .ok_or_else(|| anyhow!("Profile not found"))?
        };

        let reporter = MarkdownReporter::default();
        let path: PathBuf = profile.file_path.clone().into();
        let path_for_task = path.clone();
        let analysis = tokio::task::spawn_blocking(move || analyze_path(&path_for_task)).await??;
        let report_markdown = reporter.render(
            &analysis.result,
            &layercake_code_analysis::report::ReportMetadata::new(path, analysis.files_scanned),
        )?;
        let cleaned_report = strip_csv_blocks(&report_markdown);

        // Persist graph into dataset
        let dataset_id = match profile.dataset_id {
            Some(id) => id,
            None => {
                let ds_service = DataSetService::new(self.db.clone());
                ds_service
                    .create_empty(
                        profile.project_id,
                        "Code analysis".to_string(),
                        Some("Generated by code analysis".to_string()),
                    )
                    .await?
                    .id
            }
        };

        let graph_json = serde_json::to_string(&analysis_to_graph(
            &analysis.result,
            Some(cleaned_report.clone()),
        ))?;
        let ds_service = DataSetService::new(self.db.clone());
        ds_service.update_graph_data(dataset_id, graph_json).await?;

        let mut profiles = self.profiles.lock().await;
        let updated = profiles
            .get_mut(id)
            .ok_or_else(|| anyhow!("Profile missing after run"))?;
        updated.dataset_id = Some(dataset_id);
        updated.last_run = Some(Utc::now());
        updated.report = Some(cleaned_report);

        Ok(updated.clone())
    }
}
