use std::path::PathBuf;

use anyhow::{anyhow, Result};
use chrono::{DateTime, Utc};
use layercake_code_analysis::analyzer::analyze_path;
use layercake_code_analysis::report::markdown::{strip_csv_blocks, MarkdownReporter};
use sea_orm::{
    ActiveModelTrait, ColumnTrait, DatabaseConnection, EntityTrait, IntoActiveModel, QueryFilter,
    Set,
};
use serde::{Deserialize, Serialize};
use uuid::Uuid;

use crate::code_analysis_graph::analysis_to_graph;
use crate::database::entities::code_analysis_profiles;
use crate::services::data_set_service::DataSetService;

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct CodeAnalysisProfile {
    pub id: String,
    pub project_id: i32,
    pub file_path: String,
    pub dataset_id: Option<i32>,
    pub last_run: Option<DateTime<Utc>>,
    pub report: Option<String>,
}

impl From<code_analysis_profiles::Model> for CodeAnalysisProfile {
    fn from(model: code_analysis_profiles::Model) -> Self {
        Self {
            id: model.id,
            project_id: model.project_id,
            file_path: model.file_path,
            dataset_id: model.dataset_id,
            last_run: model.last_run,
            report: model.report,
        }
    }
}

#[derive(Clone)]
pub struct CodeAnalysisService {
    db: DatabaseConnection,
}

impl CodeAnalysisService {
    pub fn new(db: DatabaseConnection) -> Self {
        Self { db }
    }

    pub async fn list(&self, project_id: i32) -> Result<Vec<CodeAnalysisProfile>> {
        let results = code_analysis_profiles::Entity::find()
            .filter(code_analysis_profiles::Column::ProjectId.eq(project_id))
            .all(&self.db)
            .await?;
        Ok(results.into_iter().map(CodeAnalysisProfile::from).collect())
    }

    pub async fn create(
        &self,
        project_id: i32,
        file_path: String,
        dataset_id: Option<i32>,
    ) -> Result<CodeAnalysisProfile> {
        let id = Uuid::new_v4().to_string();
        let active = code_analysis_profiles::ActiveModel {
            id: Set(id.clone()),
            project_id: Set(project_id),
            file_path: Set(file_path),
            dataset_id: Set(dataset_id),
            last_run: Set(None),
            report: Set(None),
        };

        code_analysis_profiles::Entity::insert(active.clone())
            .exec(&self.db)
            .await?;

        let model = code_analysis_profiles::Entity::find_by_id(id.clone())
            .one(&self.db)
            .await?
            .ok_or_else(|| anyhow!("Failed to find inserted item"))?;

        Ok(CodeAnalysisProfile::from(model))
    }

    pub async fn update(
        &self,
        id: &str,
        file_path: Option<String>,
        dataset_id: Option<Option<i32>>,
    ) -> Result<CodeAnalysisProfile> {
        let mut model = code_analysis_profiles::Entity::find_by_id(id.to_string())
            .one(&self.db)
            .await?
            .ok_or_else(|| anyhow!("Profile not found"))?
            .into_active_model();

        if let Some(path) = file_path {
            model.file_path = Set(path);
        }
        if let Some(ds) = dataset_id {
            model.dataset_id = Set(ds);
        }

        let updated = model.update(&self.db).await?;
        Ok(CodeAnalysisProfile::from(updated))
    }

    pub async fn delete(&self, id: &str) -> Result<bool> {
        let result = code_analysis_profiles::Entity::delete_by_id(id.to_string())
            .exec(&self.db)
            .await?;
        Ok(result.rows_affected > 0)
    }

    async fn get_by_id(&self, id: &str) -> Result<code_analysis_profiles::Model> {
        code_analysis_profiles::Entity::find_by_id(id.to_string())
            .one(&self.db)
            .await?
            .ok_or_else(|| anyhow!("Profile not found"))
    }

    pub async fn run(&self, id: &str) -> Result<CodeAnalysisProfile> {
        let profile = self.get_by_id(id).await?;

        let reporter = MarkdownReporter::default();
        let path: PathBuf = profile.file_path.clone().into();
        let path_for_task = path.clone();
        let analysis = tokio::task::spawn_blocking(move || analyze_path(&path_for_task)).await??;
        let report_markdown = reporter.render(
            &analysis.result,
            &layercake_code_analysis::report::ReportMetadata::new(path, analysis.files_scanned),
        )?;
        let cleaned_report = strip_csv_blocks(&report_markdown);

        let dataset_id = match profile.dataset_id {
            Some(id) => id,
            None => {
                let ds_service = DataSetService::new(self.db.clone());
                ds_service
                    .create_empty(
                        profile.project_id,
                        "Code analysis".to_string(),
                        Some("Generated by code analysis".to_string()),
                    )
                    .await?
                    .id
            }
        };

        let graph_json = serde_json::to_string(&analysis_to_graph(
            &analysis.result,
            Some(cleaned_report.clone()),
        ))?;
        let ds_service = DataSetService::new(self.db.clone());
        ds_service.update_graph_data(dataset_id, graph_json).await?;

        let mut active = profile.into_active_model();
        active.dataset_id = Set(Some(dataset_id));
        active.last_run = Set(Some(Utc::now()));
        active.report = Set(Some(cleaned_report));

        let updated = active.update(&self.db).await?;
        Ok(CodeAnalysisProfile::from(updated))
    }
}
