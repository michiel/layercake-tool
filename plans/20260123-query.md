# Query Interface Improvements for Agent Usability

**Date:** 2026-01-23
**Status:** Planning
**Goal:** Enhance the `layercake query` interface to make it more powerful and usable for AI agents working alongside human users

## Current Limitations

Based on hands-on usage, the current query interface has these constraints:

1. **No filtering** - Must retrieve full DAG and filter locally
2. **No graph traversal** - Cannot query upstream/downstream relationships
3. **Single operations only** - No batch creation/updates
4. **Limited introspection** - Cannot discover available options programmatically
5. **No node-specific queries** - Cannot get a single node without the full DAG
6. **No search** - Cannot find nodes by label or description
7. **No validation helpers** - Must construct payloads from examples
8. **No graph analysis** - Cannot query metrics, paths, or structure

## Proposed Enhancements

### 1. Node Query Filters

**Problem:** `nodes list` returns the entire DAG. For large plans, this is inefficient.

**Solution:** Add filter parameters to the `list` action.

```bash
# Filter by node type
layercake query --entity nodes --action list --project 34 --plan 37 \
  --payload-json '{"nodeType": "GraphNode"}'

# Filter by label pattern
layercake query --entity nodes --action list --project 34 --plan 37 \
  --payload-json '{"labelPattern": "Copilot*"}'

# Filter by execution state
layercake query --entity nodes --action list --project 34 --plan 37 \
  --payload-json '{"executionState": "completed"}'

# Get specific node without full DAG
layercake query --entity nodes --action get --project 34 --plan 37 \
  --payload-json '{"nodeId": "graph_42b0374af121"}'

# Get nodes by position bounds (visible viewport)
layercake query --entity nodes --action list --project 34 --plan 37 \
  --payload-json '{"bounds": {"minX": 0, "maxX": 1000, "minY": 0, "maxY": 1000}}'
```

**Implementation:**
- Add filter fields to query handler
- Use SQL WHERE clauses for efficient filtering
- Support multiple filters combined with AND logic

### 2. Graph Traversal Operations

**Problem:** Cannot query relationships without manual edge traversal.

**Solution:** Add new action `traverse` to explore graph structure.

```bash
# Get all downstream nodes from a starting node
layercake query --entity nodes --action traverse --project 34 --plan 37 \
  --payload-json '{
    "startNode": "dataset_fb5f819c7089",
    "direction": "downstream",
    "maxDepth": 3
  }'

# Get all upstream nodes (dependencies)
layercake query --entity nodes --action traverse --project 34 --plan 37 \
  --payload-json '{
    "startNode": "graph_42b0374af121",
    "direction": "upstream"
  }'

# Get path between two nodes
layercake query --entity nodes --action traverse --project 34 --plan 37 \
  --payload-json '{
    "startNode": "dataset_fb5f819c7089",
    "endNode": "graphartefact_af32487bb03c",
    "findPath": true
  }'

# Get subgraph (node and all its connections)
layercake query --entity nodes --action traverse --project 34 --plan 37 \
  --payload-json '{
    "startNode": "graph_42b0374af121",
    "includeConnections": true,
    "radius": 1
  }'
```

**Response:**
```json
{
  "status": "ok",
  "result": {
    "nodes": [...],
    "edges": [...],
    "paths": [["node1", "node2", "node3"]],
    "depth": 2
  }
}
```

### 3. Batch Operations

**Problem:** Creating complex structures requires many sequential calls.

**Solution:** Add `batch` action for multiple operations in one request.

```bash
# Create multiple nodes and edges atomically
layercake query --entity nodes --action batch --project 34 --plan 37 \
  --payload-file batch-operations.json
```

**batch-operations.json:**
```json
{
  "operations": [
    {
      "op": "createNode",
      "id": "temp_node_1",
      "data": {
        "nodeType": "GraphNode",
        "position": {"x": 100, "y": 100},
        "metadata": {"label": "Stage 1"}
      }
    },
    {
      "op": "createNode",
      "id": "temp_node_2",
      "data": {
        "nodeType": "GraphNode",
        "position": {"x": 300, "y": 100},
        "metadata": {"label": "Stage 2"}
      }
    },
    {
      "op": "createEdge",
      "data": {
        "source": "$temp_node_1",
        "target": "$temp_node_2",
        "metadata": {"label": "Flow", "data_type": "GraphData"}
      }
    }
  ],
  "atomic": true
}
```

**Features:**
- Reference temporary IDs with `$` prefix
- Atomic transactions (all or nothing)
- Returns mapping of temporary IDs to actual IDs

### 4. Search and Discovery

**Problem:** Cannot search for nodes by content or find similar items.

**Solution:** Add `search` action with flexible query syntax.

```bash
# Search nodes by label or description
layercake query --entity nodes --action search --project 34 --plan 37 \
  --payload-json '{
    "query": "copilot",
    "fields": ["label", "description"]
  }'

# Search by configuration content
layercake query --entity nodes --action search --project 34 --plan 37 \
  --payload-json '{
    "query": "dataSetId:182"
  }'

# Find nodes connected to a specific dataset
layercake query --entity edges --action search --project 34 --plan 37 \
  --payload-json '{
    "source": "dataset_fb5f819c7089"
  }'

# Find all nodes without outgoing edges (leaf nodes)
layercake query --entity nodes --action search --project 34 --plan 37 \
  --payload-json '{
    "edgeFilter": "noOutgoing"
  }'
```

### 5. Graph Analysis Operations

**Problem:** Cannot get structural insights or metrics.

**Solution:** Add new entity `analysis` for graph analytics.

```bash
# Get graph statistics
layercake query --entity analysis --action stats --project 34 --plan 37 \
  --pretty

# Find critical paths (longest dependency chains)
layercake query --entity analysis --action criticalPath --project 34 --plan 37 \
  --payload-json '{"startNodes": ["dataset_fb5f819c7089"]}'

# Detect cycles
layercake query --entity analysis --action detectCycles --project 34 --plan 37

# Get node importance metrics
layercake query --entity analysis --action centrality --project 34 --plan 37 \
  --payload-json '{"nodeId": "graph_42b0374af121"}'

# Identify bottlenecks (high-degree nodes)
layercake query --entity analysis --action bottlenecks --project 34 --plan 37 \
  --payload-json '{"threshold": 5}'
```

**Response for stats:**
```json
{
  "status": "ok",
  "result": {
    "nodeCount": 13,
    "edgeCount": 10,
    "nodesByType": {
      "DataSetNode": 3,
      "GraphNode": 3,
      "GraphArtefactNode": 7
    },
    "maxDepth": 3,
    "leafNodes": 7,
    "avgDegree": 1.54,
    "isolatedNodes": 0
  }
}
```

### 6. Schema Introspection

**Problem:** Must refer to documentation to know what fields are available.

**Solution:** Add `schema` entity for self-documentation.

```bash
# Get schema for node types
layercake query --entity schema --action describe \
  --payload-json '{"type": "node", "nodeType": "GraphNode"}'

# Get available actions for an entity
layercake query --entity schema --action actions \
  --payload-json '{"entity": "nodes"}'

# Get example payloads
layercake query --entity schema --action example \
  --payload-json '{"entity": "nodes", "action": "create", "nodeType": "GraphArtefactNode"}'

# List all node types
layercake query --entity schema --action types

# Get render config schema
layercake query --entity schema --action describe \
  --payload-json '{"type": "renderConfig", "format": "Mermaid"}'
```

**Response:**
```json
{
  "status": "ok",
  "result": {
    "type": "GraphNode",
    "fields": {
      "nodeType": {"type": "string", "required": true, "values": ["GraphNode"]},
      "position": {"type": "Position", "required": true},
      "metadata": {
        "type": "object",
        "fields": {
          "label": {"type": "string", "required": false},
          "description": {"type": "string", "required": false}
        }
      },
      "config": {
        "type": "object",
        "fields": {
          "metadata": {"type": "object", "required": false}
        }
      }
    },
    "example": { /* full example payload */ }
  }
}
```

### 7. Validation and Dry-Run

**Problem:** Errors only discovered after submission.

**Solution:** Add `validate` action and `--dry-run` flag.

```bash
# Validate payload without executing
layercake query --entity nodes --action create --project 34 --plan 37 \
  --payload-json '{...}' --dry-run

# Explicit validation
layercake query --entity nodes --action validate --project 34 --plan 37 \
  --payload-json '{
    "operation": "create",
    "data": {...}
  }'
```

**Response:**
```json
{
  "status": "error",
  "result": {
    "valid": false,
    "errors": [
      {
        "field": "position",
        "message": "Missing required field 'position'",
        "suggestion": "Add position with x and y coordinates"
      },
      {
        "field": "config",
        "message": "Invalid JSON string in config field",
        "suggestion": "Ensure config is a valid JSON string"
      }
    ]
  }
}
```

### 8. Annotations and Metadata

**Problem:** Limited ability to add context or tags to nodes/edges.

**Solution:** Add `annotations` entity for flexible metadata.

```bash
# Add annotation to a node
layercake query --entity annotations --action create --project 34 --plan 37 \
  --payload-json '{
    "targetId": "graph_42b0374af121",
    "targetType": "node",
    "key": "owner",
    "value": "data-team"
  }'

# Add tags
layercake query --entity annotations --action create --project 34 --plan 37 \
  --payload-json '{
    "targetId": "graph_42b0374af121",
    "targetType": "node",
    "key": "tags",
    "value": ["production", "copilot", "databricks"]
  }'

# Add comment
layercake query --entity annotations --action create --project 34 --plan 37 \
  --payload-json '{
    "targetId": "graph_42b0374af121",
    "targetType": "node",
    "key": "comment",
    "value": "This graph processes copilot agent flow across CICD",
    "author": "agent",
    "timestamp": "2026-01-23T08:00:00Z"
  }'

# List annotations for a node
layercake query --entity annotations --action list --project 34 --plan 37 \
  --payload-json '{"targetId": "graph_42b0374af121"}'

# Search by annotation
layercake query --entity nodes --action search --project 34 --plan 37 \
  --payload-json '{
    "annotation": {"key": "tags", "value": "production"}
  }'
```

### 9. Template and Clone Operations

**Problem:** Repetitive node creation for similar patterns.

**Solution:** Add template support and clone operations.

```bash
# Clone a node
layercake query --entity nodes --action clone --project 34 --plan 37 \
  --payload-json '{
    "nodeId": "graph_42b0374af121",
    "position": {"x": 800, "y": 1200},
    "updateLabel": "Copilot 004"
  }'

# Clone subgraph
layercake query --entity nodes --action clone --project 34 --plan 37 \
  --payload-json '{
    "nodeId": "graph_42b0374af121",
    "includeConnections": true,
    "depth": 2,
    "offset": {"x": 500, "y": 0}
  }'

# Save as template
layercake query --entity templates --action create --project 34 --plan 37 \
  --payload-json '{
    "name": "Standard Graph Pipeline",
    "nodeIds": ["dataset_fb5f819c7089", "graph_42b0374af121", "graphartefact_af32487bb03c"]
  }'

# Apply template
layercake query --entity templates --action apply --project 34 --plan 37 \
  --payload-json '{
    "templateId": 5,
    "position": {"x": 100, "y": 500},
    "parameters": {
      "dataSetId": 183
    }
  }'
```

### 10. Version History and Diff

**Problem:** Cannot see what changed or revert changes.

**Solution:** Add version tracking and diff capabilities.

```bash
# List plan versions
layercake query --entity plans --action versions --project 34 \
  --payload-json '{"id": 37}'

# Get diff between versions
layercake query --entity plans --action diff --project 34 \
  --payload-json '{
    "planId": 37,
    "fromVersion": 54,
    "toVersion": 55
  }'

# Revert to previous version
layercake query --entity plans --action revert --project 34 \
  --payload-json '{
    "planId": 37,
    "toVersion": 54,
    "createBackup": true
  }'
```

**Diff response:**
```json
{
  "status": "ok",
  "result": {
    "changes": [
      {
        "type": "nodeUpdated",
        "nodeId": "graphartefact_af32487bb03c",
        "field": "config.renderConfig.orientation",
        "oldValue": "TB",
        "newValue": "LR"
      },
      {
        "type": "nodeCreated",
        "nodeId": "graph_xyz123",
        "data": {...}
      }
    ],
    "summary": {
      "nodesCreated": 1,
      "nodesUpdated": 1,
      "nodesDeleted": 0,
      "edgesChanged": 0
    }
  }
}
```

### 11. Query Language (Advanced)

**Problem:** Complex queries require multiple CLI calls.

**Solution:** Add JSON-based query language for complex operations.

```bash
layercake query --entity nodes --action query --project 34 --plan 37 \
  --payload-file complex-query.json
```

**complex-query.json:**
```json
{
  "select": {
    "nodes": ["id", "metadata.label", "position", "graph_execution.node_count"],
    "edges": ["id", "source", "target", "metadata.data_type"]
  },
  "where": {
    "and": [
      {"node.nodeType": "GraphNode"},
      {"node.graph_execution.execution_state": "completed"},
      {"node.graph_execution.node_count": {">": 40}}
    ]
  },
  "include": {
    "edges": {
      "direction": "outgoing"
    }
  },
  "orderBy": "graph_execution.node_count",
  "order": "desc",
  "limit": 10
}
```

**Response:**
```json
{
  "status": "ok",
  "result": {
    "nodes": [
      {
        "id": "graph_42b0374af121",
        "metadata": {"label": "Copilot 003"},
        "position": {"x": 619.04, "y": 1206.43},
        "graph_execution": {"node_count": 45}
      }
    ],
    "edges": [...],
    "count": 1
  }
}
```

### 12. Improved Error Messages

**Problem:** Error messages are generic and not actionable.

**Solution:** Enhanced error responses with suggestions.

```json
{
  "status": "error",
  "message": "Node with ID 'graph_invalid' not found",
  "context": {
    "project": 34,
    "plan": 37,
    "requestedId": "graph_invalid"
  },
  "suggestions": [
    "Did you mean 'graph_42b0374af121'?",
    "Did you mean 'graph_f9cc417fafce'?",
    "Use 'layercake query --entity nodes --action list' to see all available nodes"
  ],
  "documentation": "https://docs.layercake.tool/errors/node-not-found"
}
```

### 13. Export Enhancements

**Problem:** Limited control over what gets exported.

**Solution:** Add filtering and projection to exports.

```bash
# Export with node filtering
layercake query --entity exports --action download \
  --payload-json '{
    "graphId": 1001128,
    "format": "Mermaid",
    "filter": {
      "excludeNodeTypes": ["GraphArtefactNode"]
    }
  }'

# Export subgraph only
layercake query --entity exports --action download \
  --payload-json '{
    "graphId": 1001128,
    "format": "JSON",
    "subgraph": {
      "centerNode": "graph_42b0374af121",
      "radius": 2
    }
  }'

# Export with anonymisation (for sharing)
layercake query --entity exports --action download \
  --payload-json '{
    "graphId": 1001128,
    "format": "Mermaid",
    "anonymise": true,
    "preserveStructure": true
  }'
```

### 14. Interactive Mode

**Problem:** Each query requires full command syntax.

**Solution:** Add interactive REPL mode.

```bash
layercake query --interactive --database layercake.db --project 34 --plan 37

# In interactive mode:
layercake> use project 34 plan 37
layercake> list nodes where nodeType=GraphNode
layercake> get node graph_42b0374af121
layercake> traverse downstream from graph_42b0374af121
layercake> export graph 1001128 as mermaid to file.mmd
layercake> search "copilot"
layercake> help traverse
layercake> exit
```

### 15. Watch Mode

**Problem:** Cannot monitor changes made by the user in the web UI.

**Solution:** Add watch mode for real-time updates.

```bash
# Watch for changes in a plan
layercake query --entity plans --action watch --project 34 \
  --payload-json '{"planId": 37}'

# Outputs JSON events:
{"event": "nodeCreated", "nodeId": "graph_xyz", "timestamp": "..."}
{"event": "nodeUpdated", "nodeId": "graph_42b0374af121", "fields": ["position"]}
{"event": "edgeDeleted", "edgeId": "edge_abc123"}
```

## Implementation Priority

### Phase 1: Essential Improvements (High Priority)
1. Node query filters (filter by type, label, execution state)
2. Single node GET without full DAG
3. Graph traversal (upstream/downstream)
4. Schema introspection
5. Improved error messages
6. Validation/dry-run

**Impact:** Makes basic queries 10x faster and more usable

### Phase 2: Productivity Enhancements (Medium Priority)
7. Batch operations
8. Search and discovery
9. Graph analysis (stats, paths)
10. Annotations and tags
11. Clone operations

**Impact:** Enables complex workflows without scripting

### Phase 3: Advanced Features (Lower Priority)
12. Template system
13. Version history and diff
14. Query language
15. Interactive mode
16. Watch mode
17. Export enhancements

**Impact:** Power user features for sophisticated use cases

## Technical Considerations

### Backwards Compatibility
- All new features should be additive (no breaking changes)
- Existing commands must continue to work
- New actions/entities should not conflict with existing ones

### Performance
- Filter operations should use SQL WHERE clauses, not in-memory filtering
- Traversal should use efficient graph algorithms
- Batch operations should use transactions
- Large responses should support pagination

### API Design Principles
1. **Consistency**: Similar operations should have similar syntax
2. **Discoverability**: Use schema introspection to learn the API
3. **Validation**: Fail fast with clear error messages
4. **Atomicity**: Batch operations should be atomic where possible
5. **Idempotency**: Same request should produce same result

### Database Schema Changes

Some features may require schema additions:
- **Annotations table**: For flexible metadata
- **Templates table**: For reusable patterns
- **Version history**: Track plan changes over time
- **Indices**: On node types, labels, positions for fast filtering

### Testing Strategy
- Unit tests for each new action
- Integration tests for batch operations
- Performance tests for large graphs (1000+ nodes)
- Backwards compatibility tests

## Success Metrics

How to measure if these improvements are successful:

1. **Reduced query count** - Common tasks should require fewer CLI calls
2. **Faster responses** - Filtered queries should be <100ms for typical plans
3. **Lower error rate** - Validation should catch errors before submission
4. **User satisfaction** - Both human and AI agents should find it more intuitive
5. **Code coverage** - New features should have >90% test coverage

## Example Use Cases Enabled

### Use Case 1: Documenting a Complex Plan
```bash
# Get overview
layercake query --entity analysis --action stats --project 34 --plan 37

# Find all data sources
layercake query --entity nodes --action list --project 34 --plan 37 \
  --payload-json '{"nodeType": "DataSetNode"}'

# Trace each source through to outputs
for dataset in $(list datasets); do
  layercake query --entity nodes --action traverse --project 34 --plan 37 \
    --payload-json "{\"startNode\": \"$dataset\", \"direction\": \"downstream\"}"
done

# Add documentation annotations
layercake query --entity annotations --action create --project 34 --plan 37 \
  --payload-json '{
    "targetId": "graph_42b0374af121",
    "key": "documentation",
    "value": "Processes copilot agent flows across CICD, source and target data systems"
  }'
```

### Use Case 2: Rapid Prototyping
```bash
# Clone existing pipeline
layercake query --entity templates --action create --project 34 --plan 37 \
  --payload-json '{"name": "Standard Pipeline", "nodeIds": ["dataset_fb5f819c7089", "graph_42b0374af121"]}'

# Apply to new dataset
layercake query --entity templates --action apply --project 34 --plan 37 \
  --payload-json '{"templateId": 1, "parameters": {"dataSetId": 184}}'

# Batch create artefacts
layercake query --entity nodes --action batch --project 34 --plan 37 \
  --payload-file create-all-artefacts.json
```

### Use Case 3: Quality Assurance
```bash
# Find all failed executions
layercake query --entity nodes --action search --project 34 --plan 37 \
  --payload-json '{"executionState": "failed"}'

# Detect cycles
layercake query --entity analysis --action detectCycles --project 34 --plan 37

# Find orphaned nodes
layercake query --entity nodes --action search --project 34 --plan 37 \
  --payload-json '{"edgeFilter": "isolated"}'

# Validate all graph artefact configs
layercake query --entity nodes --action list --project 34 --plan 37 \
  --payload-json '{"nodeType": "GraphArtefactNode"}' \
  | jq -r '.result.nodes[].node.id' \
  | while read id; do
      layercake query --entity nodes --action validate --project 34 --plan 37 \
        --payload-json "{\"nodeId\": \"$id\"}"
    done
```

### Use Case 4: Collaborative Work
```bash
# Watch for user's changes
layercake query --entity plans --action watch --project 34 --plan 37 &

# When user adds a node, automatically add documentation
# (triggered by watch event)
layercake query --entity annotations --action create --project 34 --plan 37 \
  --payload-json "{\"targetId\": \"$NEW_NODE_ID\", \"key\": \"created_by\", \"value\": \"agent\"}"

# Suggest improvements based on analysis
layercake query --entity analysis --action bottlenecks --project 34 --plan 37
# Returns: "Node graph_42b0374af121 has 3 outputs, consider splitting into smaller graphs"
```

## Open Questions

1. **Authentication**: How should session/auth work for multi-user scenarios?
2. **Permissions**: Should agents have restricted capabilities vs full admin?
3. **Rate limiting**: Should there be limits on batch operations?
4. **Webhooks**: Should plan changes trigger external webhooks?
5. **Graph size limits**: What's the maximum reasonable graph size to support?
6. **Export formats**: What additional export formats would be useful (YAML, XML, SQL)?
7. **API versioning**: How to handle future breaking changes?

## Related Work

Consider integration with:
- GraphQL endpoint (alternative to CLI)
- REST API (for web service integration)
- Python/JavaScript SDKs (for scripting)
- VS Code extension (for IDE integration)

## Conclusion

These improvements would transform the query interface from a basic CRUD tool into a powerful graph manipulation and analysis platform. The phased approach allows incremental delivery while maintaining backwards compatibility.

Key benefits:
- **For AI Agents**: Faster queries, fewer round-trips, better error handling
- **For Human Users**: More powerful CLI for automation and scripting
- **For Both**: Clearer documentation through introspection, validation before errors

Next steps:
1. Review and prioritise features with stakeholders
2. Create detailed technical specs for Phase 1
3. Set up test infrastructure
4. Begin implementation starting with node filters
